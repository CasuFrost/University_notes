\documentclass[12pt, letterpaper]{article}
\usepackage{graphicx} % Required for inserting images
\usepackage{hyperref}
\usepackage{listings}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage[english]{babel}
\usepackage{nicefrac, xfrac}
\usepackage{mathtools}
\usepackage[table,xcdraw]{xcolor}
\definecolor{light-gray}{gray}{0.95}
\definecolor{sap}{RGB}{130, 36, 51}
\definecolor{lg}{RGB}{102, 161, 95}
\usepackage[paper=a4paper,left=20mm,right=20mm,bottom=25mm,top=25mm]{geometry}
\newcommand{\code}[1]{\colorbox{light-gray}{\texttt{#1}}}
\newcommand{\shelll}[1]{\colorbox{black}{\textcolor{white}{\texttt{#1}}}}
\newcommand{\shell}[1]{\colorbox{black}{\textcolor{white}{\texttt{casufrost@debian:$\sim$\$ #1}}}}
\newcommand{\codee}[1]{\colorbox{white}{\texttt{#1}}}
\newcommand{\acc}{\\\hphantom{}\\}
\newcommand{\comm}[1]{\color{lg}\textit{\hphantom{spaz}// \text{#1}}\color{black}}
\newcommand{\dete}{{\rightarrow}}
\newcommand{\fdot}{{\(\bullet\) }}
\newcommand{\boxedMath}[1]{\begin{tabular}{|c|}\hline \texttt{#1} \\ \hline\end{tabular} :}
\title{Progettazione di Algoritmi}
\author{Marco Casu}
\date{\vspace{-5ex}}
\begin{document}



\maketitle
\begin{figure}[h]
    \centering{
    \includegraphics[width=1\textwidth ]{images/cop.jpg}
    }
\end{figure}
\newpage 
\tableofcontents
\newpage
\section{Grafi}
\subsection{Introduzione e Definizioni}
Un grafo, è una coppia $(V,E)$, dove $V$ è un insieme di \textit{nodi o vertici}, ed $E$ un 
insieme di archi che collegano i nodi. Un grafo è detto \textbf{semplice} se, per ogni 
coppia di nodi, essi sono collegati da al massimo un arco, e non esistono dei cicli su 
un singolo nodo. Nel corso ci occuperemo di \textit{visitare} i grafi in 
profondità ed in ampiezza (concetti che verranno ripresi più in avanti). \acc 
Un grafo, può vedere i suoi archi \textit{orientati}, in questo caso si dice che 
il grafo è \textbf{diretto}. Due nodi sono \textbf{adiacenti} se collegati da un arco, 
ed il \textbf{grado} di un nodo non è altro che il numero di nodi adiacenti ad esso.\begin{center}
    \includegraphics[width=1\textwidth ]{images/defGrafi.eps}
\end{center}
Esiste un problema classico dal 1700, noto come \textit{problema dei ponti di Königsberg}, 
si consideri la seguente città posta nei pressi di un fiume che la divide in diversi settori, collegati 
da appositi ponti, rappresentata con il seguente grafo :\begin{center}
    \includegraphics[width=1\textwidth ]{images/konigsberg.eps}
\end{center}
Ci si chiede se è possibile passeggiare per la città, visitando tutti i settori, senza passare per due volte 
sullo stesso ponte. Consideriamo il modello del grafo, una passeggiata su un grafo non è altro che una 
sequenza ordinata di vertici ed archi che si alternano, come : $v_0,e_1,v_1\dots, e_k,v_k$.
Esiste una passeggiata su questo grafo, ossia una sequenza che non vede ripetizioni degli archi?\acc 
\textbf{Osservazione} : Per visitare un nodo è necessario passare per due archi, uno entrante ed uno uscente. 
Se entriamo in un nodo di grado 3, resterà un arco non visitato, per visitarlo sarà necessario entravi nuovamente 
da tale arco, per poi uscire da un altro precedentemente già visitato (questo ovviamente se non si comincia la 
passeggiata dal nodo in questione).\acc 
Ci rende chiaro il seguente fatto : Se il grado di un nodo $x$ è dispari, a meno che la passeggiata non inizi 
o finisca su $x$, uno dei suoi archi verrà attraversato più di una volta. \textit{Eulero} studiò questo problema, 
si dice infatti che la passeggiata su un grafo è \textbf{euleriana} se non si passa 2 volte sulle stesso arco.\acc 
Si consideri però il seguente grafo :\begin{center}
    \includegraphics[width=1\textwidth ]{images/nonConnesso.eps}
\end{center}
Un grafo si dice \textbf{connesso} se, per ogni coppia di vertici, essi sono collegati da una passeggiata, 
ossia è possibile raggiungere un vertice partendo da un altro. Le precedenti osservazioni ci portano al 
seguente risultato.\acc 
\textbf{Teorema (Eulero)} : Un grafo ha una passeggiata euleriana se e solo se è connesso, ed 
esistono al massimo 2 vertici di grado dispari.\acc 
Il fatto che sono concessi 2 vertici di grado dispari, è dato dal fatto che essi saranno l'inizio e la fine 
della passeggiata.
\subsection{Rappresentazione Fisica}
Che struttura dati possiamo utilizzare per rappresentare un grafo? Vediamo due alternative : \begin{itemize}
    \item \textbf{Matrice di Adiacenza} - Utilizziamo una matrice $n\times n$, dove \(n\) è il numero di 
    nodi del grafo. Nella posizione \(i,j\) ci sarà 1 se il vertice \(v_i\) è adiacente al vertice 
    \(v_j\), altrimenti 0. Il costo di "\textit{check}" per l'adiacenza di due vertici è costante, basta 
    consultare un entrata della matrice, nonostante ciò, lo spazio che occupa tale rappresentazione è 
    \(O(n^2)\).
    \item \textbf{Liste di Adiacenza} - Ad ogni vertice del grafo è associata una lista, contenente tutti 
    i suoi vertici adiacenti, per controllare se due vertici sono adiacenti, è necessario fare una ricerca 
    lineare su tale lista, ed ha costo $\displaystyle O(\deg(v))$, dove \(v\) è il vertice sulla 
    quale si sta effettuando la ricerca, ed è ovviamente limitato da \(n-1\) (numero di vertici).\acc
    Le dimensioni della struttura dati sono $\displaystyle O\big(n + \sum_{v\in V(G)}\deg(v)\big)$.
\end{itemize}
Nel caso in cui un grafo dovesse vedere ogni vertice adiacente a tutti gli altri, la ricerca costerebbe 
\(O(n)\) e le dimensioni sarebbero \(O(n^2)\), ciò differisce però dal caso reale, la rappresentazione con 
liste di adiacenza risulta un buon compromesso fra costo computazionale e dimensioni.
Sarà usuale denotare \(m\) il numero di archi e \(n\) il numero di vertici.
Le liste di adiacenza occupano quindi spazio $O(n+m)$,  si osservi inoltre la 
seguente identià : $$\sum_{v\in V(G)}\deg(v)=2\cdot m\text{ dove }m:=|E|$$
\subsection{Ricerca di un Ciclo}
\textbf{Definizione} : Un \textit{ciclo} in un grafo, non p altro che un \textit{sottografo connesso} dove 
ogni vertice è di grado 2. Identifica un "cammino circolare", e la ricerca dei cicli nei grafi è un 
problema molto noto.\begin{center}
    \includegraphics[width=0.8\textwidth ]{images/ciclo.eps}
\end{center}
Consideriamo adesso un problema, vogliamo definire un algoritmo che, dato in input un grafo \(G=(V,E)\), dove ogni 
vertice ha grado maggiore o uguale a 2, restituisca in output un qualsiasi ciclo presente nel grafo, mantenendo 
un costo computazionele $O(n+m)=O(|V|+|E)$. 
\begin{quote}
    Si consideri la seguente \textit{idea} informale di soluzione : \end{quote}  
    Ogni vertice ha almeno 2 nodi adiacenti, è quindi sempre possibile entrare in un vertice ed uscirne da un
    arco diverso da quello dalla quale si è entrati. Si parte da un qualsiasi vertice nel grafo, e si procede 
    selezionando uno qualsiasi dei due nodi adiacenti successivi, almeno uno dei due non sarà quello dalla 
    quale si è entrati, procederemo in questa maniera camminando in maniera casuale sul grafo, finchè non troveremo 
    un nodo che è stato già visitato in precedenza, ciò indica che si è eseguito un cammino ciclico.\acc 
Utilizzeremo un vettore con lo scopo di salvare i nodi visitati, il ciclo sarà rappresentato 
dai nodi presenti nel vettore, partendo dall'ultimo elemento, continuando a ritroso fino a trovare il nodo 
identico all'ultimo. Si consideri il seguente esempio in cui gli archi sono contrassegnati dall'iterazione 
dell'algoritmo nella quale sono stati attraversati : 
\begin{center}
    \includegraphics[width=0.8\textwidth ]{images/algoCiclo.eps}
\end{center}
Una volta completato la ricerca del ciclo, elimineremo dal vettore tutti gli elementi a partire dal primo 
fino all'elemento antecedente a quello identico all'elemento finale. \begin{center}
    Pseudocodice 
\end{center}
\code{Input} : Un grafo $G=(V,E)$.\\
\code{Output} : I nodi di un sottografo di \(G\) che è un ciclo.\\\hphantom{}\\
\codee{CercaCiclo(graph G)\{}\\
\hphantom{ident}\codee{x = V[random]}\color{lg}\textit{// Un vertice a caso}\color{black}\\
\hphantom{ident}\codee{W=[x]}\color{lg}\textit{// Inizializzo il vettore output}\color{black}\\
\hphantom{ident}\codee{current = V}\\
\hphantom{ident}\codee{y=adiacente di x}\color{lg}\textit{// Un adiacente a caso}\color{black}\\
\hphantom{ident}\codee{next=y}\\
\hphantom{ident}\codee{while(next$\notin$ W)\{}\\
\hphantom{ident}\hphantom{ident}\codee{W.append(next)}\\
\hphantom{ident}\hphantom{ident}\codee{current=next}\\
\hphantom{ident}\hphantom{ident}\codee{if ($1^\circ$ adiacente di current$\ne$W[W.lenght-2])\{}
\color{lg}\textit{// Il penultimo}\color{black}\\
\hphantom{ident}\hphantom{ident}\hphantom{ident}\codee{next = $1^\circ$ adiacente di current}\\
\hphantom{ident}\hphantom{ident}\codee{\}else\{next = $2^\circ$ adiacente di current}\\
\hphantom{ident}\codee{\}}\\
\hphantom{ident}\codee{while(W[0]$\ne$next)\{}\\
\hphantom{ident}\hphantom{ident}\codee{W.remove(W[0])}\color{lg}\textit{// Rimuove il primo elemento}\color{black}\\
\hphantom{ident}\codee{\}}\\
\hphantom{ident}\codee{return W}\\
\codee{\}}\acc 
Qual'è la complessita di tale algoritmo? Entrambi i cicli \code{while} eseguono \(O(n)\) iterazioni, il 
fatto è che, nel primo ciclo while, il controllo \code{next$\notin$W} deve scorrere comunque tutto il vettore, 
rendendo il costo dell'algoritmo \(O(n^2)\), non rispettando le specifiche iniziali, ossia \(O(n+m)\).
\subsection{Cammini sui Grafi}
Un \textbf{cammino}, non è altro che una passeggiata su un grafo in cui non 
si passa mai più di una volta sullo stesso vertice, ossia una passeggiata 
senzza ripetizioni di vertici o archi. \acc 
\textbf{Osservazione} : Siano $x$ ed $y$ due nodi di un grafo, se esiste 
una passeggiata da $x$ ad $y$, allore esiste anche un cammino.\acc 
Nei grafi diretti vale la stessa regola, con ovviamente il vincola che bisogna rispettare 
l'orientazione degli archi. Un grafo diretto si dice \textbf{fortemente connesso} 
se, per ogni coppia di vertici \(x,y\), esiste un cammino da \(x\) ad \(y\)
e viceversa. \begin{center}
    \includegraphics[width=0.6\textwidth ]{images/fortConnesso.eps}
\end{center}
Un noto problema è il seguente, dato un grafo \(G\) e due veritici \(x,y\), esiste un cammino da \(x\) ad \(y\)? In generale, 
il carico di lavoro per controllare ciò, equivale al carico di lavoro necessario per controllare tutti i nodi che possono essere 
"raggiunti" partendo da \(x\).\acc 
Prendo quindi un vertici \(x\) e trovo tutti i vertici \(y\) per i quali esiste un cammino fra essi, per fare ciò, occorre 
\textbf{visitare} il grafo, e può essere fatto in due modi differenti.
\subsubsection{Depth-First Search}
Abbreviato \textbf{DFS}, tale algoritmo rappresenta la visita su un grafo in \textit{profondità}. Partendo da un qualsiasi 
vertice \(x\), inizio a visitare randomicamente uno dei vertici adiacenti, per poi proseguire da esso. Se ad un certo punto non 
vi sono nuovi vertici da visitare, si esegue il cosiddetto \textit{back tracking}, controllando i nodi a ritroso e cercando 
dei nuovi vertici. Risulta quindi naturale l'uso di uno \textit{stack} per poter implementare tale ricerca. L'algoritmo 
alla fine visiterà ogni nodo per la quale esiste un cammino dal nodo iniziale.
\begin{center}
    Pseudocodice
\end{center} 
\code{Input} : Un grafo $G=(V,E)$, ed un vertice \(x\).\\
\code{Output} : L'insieme dei vertici visitati partendo da \(x\).\\
\codee{DFS(graph G, vert x)\{}\\
\hphantom{ident}\codee{S : stack = \{x\}}\\
\hphantom{ident}\codee{Vis : set = [x]}\comm{l'insieme che conterrà l'output}\\
\hphantom{ident}\codee{while(S\(\ne\emptyset\))\{}\\
\hphantom{ident}\hphantom{ident}\codee{y=S.top()}\\
\hphantom{ident}\hphantom{ident}\codee{if(\(\exists\)z adiacente ad y\(\land \)x\(\ne\)Vis)\{}\\
\hphantom{ident}\hphantom{ident}\hphantom{ident}\codee{Vis.add(z)}\\
\hphantom{ident}\hphantom{ident}\hphantom{ident}\codee{S.push(z)}\\
\hphantom{ident}\hphantom{ident}\codee{\}}\\
\hphantom{ident}\hphantom{ident}\codee{else\{}\\
\hphantom{ident}\hphantom{ident}\hphantom{ident}\codee{S.pop()}\\
\hphantom{ident}\hphantom{ident}\codee{\}}\\
\hphantom{ident}\codee{\}}\\
\hphantom{ident}\codee{return Vis}\\
\codee{\}}\acc 
Esempio di applicazione (il nodo di partenza è il nodo 1) : \begin{center}
    \includegraphics[width=1\textwidth ]{images/DFS.eps}
\end{center}
L'output dell'algoritmo sarà proprio l'insieme \code{Vis}, contenente tutti i nodi raggiungibili dal vettore input, 
bisogna dimostrare che l'algoritmo sia corretto, mostrando che ogni vertice raggiungibile da \(x\) è in \code{Vis}.\acc 
\textbf{Dimostrazione} : Supponiamo per assurdo che vi sia un vertice \(y\) tale che, esiste un cammino da \(x\) ad 
\(y\) e che \(y\) non sia presente in Vis.
$$\exists y|x\rightarrow y\land y\notin\text{Vis}$$
Essendo \(x\) il vertice di partenza, esso sicuramente si troverà in Vis, per costruzione dell'algoritmo. Questo vuol dire che 
esiste un vertice nel cammino, per la quale vale la seguente proprietà : 
\begin{center}
    \includegraphics[width=0.7\textwidth ]{images/xxx.eps}
\end{center}
Essendo \(v_i\) in Vis, vuol dire che ad un certo punto è stato nel top 
dello stack, ma \(v_{i+1}\) è adiacente a \(v_i\), quindi da quest'ultimo l'algoritmo avrà selezionato 
ad un certo punto \(v_{i+1}\), per poi proseguire da esso, per costruzione, sarà inserito in Vis, ma ciò è 
in contraddizione con l'ipotesi iniziale che \(y\) non è in Vis. \(\blacksquare\)\acc 
Questo algoritmo presenta un problema cruciale, non è efficiente, infatti risulta particolarmente 
pesante il controllo \code{if(\(\exists\)z adiacente ad y\(\land \)x\(\ne\)Vis)}, che ha costo 
computazionale \(O(\deg(y))+O(n)\). L'algoritmo va migliorato, al posto di un set, è possibile utilizzare un 
array nella seguente maniera : sarà composto da \(n:=|V|\) elementi inizializzato con tutti 0, si avrà che
 \(array[i]=1\iff i\) fa parte dell'output.\begin{center}
    Pseudocodice
\end{center} 
\codee{DFS2(graph G, vert x)\{}\\
\hphantom{ident}\codee{S : stack = \{x\}}\\
\hphantom{ident}\codee{Vis : int[n] = [0,0\(\dots \)0]}\comm{L'array in questione}\\
\hphantom{ident}\codee{while(S\(\ne\emptyset\))\{}\\
\hphantom{ident}\hphantom{ident}\codee{y=S.top()}\\
\hphantom{ident}\hphantom{ident}\codee{if(Vis[y.adiacenti[0]]==0)\{}\comm{Trova un adiacenta non ancora controllato}\\
\hphantom{ident}\hphantom{ident}\hphantom{ident}\codee{z=y.adiacenti[0]}\\
\hphantom{ident}\hphantom{ident}\hphantom{ident}\codee{Vis[z]=1}\\
\hphantom{ident}\hphantom{ident}\hphantom{ident}\codee{S.push(z)}\\
\hphantom{ident}\hphantom{ident}\hphantom{ident}\codee{y.adiacenti.remove(0)}\\
\hphantom{ident}\hphantom{ident}\codee{\}}\\
\hphantom{ident}\hphantom{ident}\codee{else\{}\\
\hphantom{ident}\hphantom{ident}\hphantom{ident}\codee{y.adiacenti.remove(0)}\\
\hphantom{ident}\hphantom{ident}\codee{\}}\\
\hphantom{ident}\hphantom{ident}\codee{if(y.adiacenti\(\ne\)0)\{S.pop()\}}\\
\hphantom{ident}\codee{\}}\\
\hphantom{ident}\codee{return Vis}\\
\codee{\}}\acc 
Si è nell'ipotesi in cui il grafo è implementato con le liste di adiacenza, infatti si noti come ogni vertice 
presenta il campo \code{adiacenti}. Per rendere più efficiente il tutto senza dover controllare ogni volta se un 
nodo è stato già visitato, semplicemente si rimuove dalla lista di adiacenza, ed ogni volta se ne prende il primo 
di tale lista che sicuramente non è stato ancora visitato, rendendo costante tale operazione.\acc 
Qual'è ora il costo computazionale? Quante  volte viene eseguito il ciclo \code{while}? Rispondere a ciò risulta 
difficile, piuttosto ci si chiede quanto lavoro devo fare nel ciclo per ogni vertice? Per ognuno di essi, si 
esegue un numero limitato di volte il comando \code{S.top()}. Nello specifico, si esegue tante volte quanto è il 
grado del vertice, risulta naturale che la complessità finale sia : 
$$O(n)+O\big( \sum_{v\in V(G)}\deg(v)\big)=O(n+|E|)=O(n+m)\text{ costo lineare}$$
Lo stesso algoritmo, si presta in maniera piuttosto naturale ad essere implementato in maniera ricorsiva, 
permettendo l'omissione dell'utilizzo di uno stack.\begin{center}
    Pseudocodice
\end{center} 
\codee{DFSRec(graph G, vert x,int[n] Vis)\{}\\
\hphantom{ident}\codee{Vis[x]=1}\\
\hphantom{ident}\codee{for each y\(\in\)x.adiacenti\{}\comm{per ogni adiacente di x}\\
\hphantom{ident}\hphantom{ident}\codee{if(Vis[y]==0)\{}\\
\hphantom{ident}\hphantom{ident}\hphantom{ident}\codee{DFSRec(G,y,Vis)}\\
\hphantom{ident}\hphantom{ident}\codee{\}}\\
\hphantom{ident}\codee{\}}\\
\codee{\}}\acc 
Il ciclo \code{for each y\(\in\)x.adiacenti} considera ogni adiacente di \(x\) una volta sola, facendo 
lo stesso lavoro di "cancellazione" dei vicini già controllati, la complessità rimane la medesima.\acc
\end{document}
