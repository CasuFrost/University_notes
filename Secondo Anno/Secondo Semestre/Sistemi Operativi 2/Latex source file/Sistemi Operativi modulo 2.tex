\documentclass[12pt, letterpaper]{article}
\usepackage{graphicx} % Required for inserting images
\usepackage{hyperref}
\usepackage{listings}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage[english]{babel}
\usepackage{nicefrac, xfrac}
\usepackage{mathtools}
\usepackage[table,xcdraw]{xcolor}
\definecolor{light-gray}{gray}{0.95}
\definecolor{sap}{RGB}{130, 36, 51}
\definecolor{lg}{RGB}{102, 161, 95}
\usepackage[paper=a4paper,left=20mm,right=20mm,bottom=25mm,top=25mm]{geometry}
\newcommand{\code}[1]{\colorbox{light-gray}{\texttt{#1}}}
\newcommand{\shelll}[1]{\colorbox{black}{\textcolor{white}{\texttt{#1}}}}
\newcommand{\shell}[1]{\colorbox{black}{\textcolor{white}{\texttt{casufrost@debian:$\sim$\$ #1}}}}
\newcommand{\codee}[1]{\colorbox{white}{\texttt{#1}}}
\newcommand{\acc}{\\\hphantom{}\\}
\newcommand{\dete}{{\rightarrow}}
\newcommand{\fdot}{{\(\bullet\) }}
\newcommand{\spaz}{{\hphantom{spazio} }}
\newcommand{\boxedMath}[1]{\begin{tabular}{|c|}\hline \texttt{#1} \\ \hline\end{tabular} :}
\title{Sistemi Operativi 2}
\author{Marco Casu}
\date{\vspace{-5ex}}
\begin{document}



\maketitle
\begin{figure}[h]
    \centering{
    \includegraphics[width=1\textwidth ]{images/cop.jpg}
    }
\end{figure}
\newpage 
\tableofcontents
\newpage
\section{Introduzione}
\subsection{Breve Panoramica su Unix}
Moltissimi sistemi operativi moderni, come \textit{MacOs}, \textit{Linux}, e molti altri, sono basati 
su \textbf{\textit{Unix}}, un sistema operativo il cui sviluppo cominciò nel lontano 1965. Inizialmente implmenetato 
totalmente in assembly, e limitato esclusivamente ad un tipo di architettura, si decise di costruire dei linguaggi 
di programmazione di più alto livello per garantire la portabilità, le versioni di Unix nei linguaggi \textit{B} e 
\textit{C} permisero di portare Unix su diverse CPU.\acc 
Venne distribuito con codice sorgente a centri di ricerca ed università, si diffuse rapidamente e nacquero diverse 
versioni. Le caratteristiche principali di un OS basato su Unix sono le seguenti: \begin{itemize}
    \item Supporta più utenti e la multiprogrammazione 
    \item Il file system ha un organizzazione gerarchica 
    \item Ha un kernel rappresentante il cuore del sistema 
    \item Si interagisce col kernel tramiite le chiamate di sistema
    \item Ha una \textit{shell} (si vedrà in seguito)
    \item È modulare e fornisce ambienti di programmazione
\end{itemize}
È composto da una serie di programmi limitati che eseguono molto bene un compito specifico, presentano un output 
minimale, sono detti "silenziosi", e lavori più complessi possono essere svolti componendo ed articolando diversi programmi 
semplici. I programmi solitamente manipolano file di testo (interpretabili dall'uomo secondo la codifica ASCII) e non file 
binari. Qualsiasi risorsa può essere vista come file o come processo.
\subsection{La Shell}
La \textbf{Shell} non è altro che un programma che esegue dei comandi, che possono essere scritti sul 
terminale, esistono vari tipi di shell, come quella denominata \textit{bash}. La bash scrive il cosiddetto 
\textit{prompt}, ossia una dicitura che indica che il terminale è in attesa di ricevere comandi, molto spesso è 
costituito dal nome dell'utente, il nome del computer, ed il percorso della directory nella quale è aperto il 
terminale.\acc
\shelll{nomeutente@nomemacchina:$\sim$\$} \textit{in attesa di ricevere comandi}
\acc 
Ogni \textbf{comando} seguirà il seguente template : Prima il nome del comando, poi le varie opzioni, e poi gli argomenti 
del comando, ci deve essere almeno un argomento obbligatorio, e zero o più argomenti opzionali, gli argomenti vanno 
separati da un carattere se indicato. \textit{Esempio} :\acc 
\shell{ps -p \$\$ -ocmd -h}
\acc 
Uno dei comandi fondamentali è \code{man}, e sta per \textit{manuale}, è un comando fondamentale che fornisce 
le informazioni più autorevoli possibile riguardo un comando, basta chiamarlo, dando come argomento appunto, il 
nome di un comando, e fornirà una lista dettagliata di tutte le opzioni ad esso correlato.\acc 
\shell{man ps} produce il seguente output : \begin{center}
    \includegraphics[width=0.7\textwidth ]{images/manPs.png}
\end{center}
Consultando il manuale è possibile capire come utilizzare i comandi fondamentali : 
\begin{itemize}
    \item \shelll{ps} - Mostra le informazioni dei processi attualmente in esecuzione.
    \item \shelll{ls} - Mostra una lista delle risorse contenute in una directory.
    \item \shelll{cp} - Copia file e directory.
\end{itemize}
Analizziamo il comando di esempio scritto in precedenza, ossia: \acc\shell{ps -p \$\$ -ocmd -h} tale comando 
mostra i processi attualmente in esecuzione, l'opzione serve a selezionare il processo in base al suo 
PID, e prede come parametro \code{\$\$}, ossia il codice identificativo del processo bash. \acc Il comando mostra 
varie informazioni, come il PID del processo ed il nome, L'opzione \code{-o} serve a selezionare solo uno dei 
parametri del processo, in questo caso prende come argomento \code{cmd} e seleziona quindi solo quel campo, ossia 
il nome. Si noti come in questo caso non è necessario lasciare uno spazio fra l'opzione e l'argomento. L'ultima opzione, 
ossia \code{-h}, serve a rimuovere il nome dei campi visualizzati, ci si aspetta quindi che tale comando in output 
restituirà esclusivamente il nome del processo bash : \acc 
\shell{ps -p \$\$ -ocmd -h}\\
\shelll{bash}\acc 
Un altro esempio : \acc 
\shell{ps -p \$\$}\\
\shelll{\space\space PID\space\space TTY\space\space\space\space\space\space TIME\space\space\space CMD\space}\\
\shelll{\space 3134\space pts/0\space\space\space 00:00:00\space bash}\acc 
Durante la configurazione di un sistema Unix è necessario specificare almeno un utente. Differenti utenti hanno 
differenti privilegi, l'utente \textbf{root}, o \textbf{superutente}, è predefinito in ogni sistema 
e possiede tutti i privilegi, è detto \textit{amministratore di sistema}.\acc 
Tale utente però, non può effettivamente eseguire un login ed entrare nel sistema, se necessario eseguire un 
operazione privilegiata, gli altri utenti possono acquisire temporaneamente i diritti di amministratore tramite 
il comando \shelll{sudo}, acronimo di \textit{super user do}.\acc 
Gli utenti appartengono a dei \textit{gruppi} che definiscono diversi privilegi, coloro che possono richiedere 
temporaneamente i diritti di amministratore appartengono al gruppo dei \textit{sudoers}, è possible mostrare 
a quali gruppi appartiene un utente tramite il comando \shelll{groups}.\acc 
\shelll{sudo} è un comando che prende come input un altro comando da eseguire in modalità root, esiste anche un altro 
comando chiamato \shelll{su}, e sta per \textit{substitute user}, e serve per cambiare utente, e diventare 
possibilmente amministratore, risulta comunque meno sicuro del comando \shelll{sudo}, in quanto quest'ultimo 
permette solo di eseguire un operazione in maniera privilegiata, senza rimanere nella condizione di root.
\section{Il File System}
La gestione dei file in un sistema Unix non è delegata al kernel, essi non risiedono infatti in quest'ultimo, e più file system 
possono coesistere nello stesso sistema : diversi dischi (o altre unità di archiviazione) possono gestire i file in maniera
 diversa. Tutti i file convivono sotto la stessa cartella radice, detta \textit{root}, in maniera totalmente trasparente.\acc 
 Il file system gestisce la memoria secondaria ed è organizzato in maniera \textbf{gerarchica}, vi è una \textit{directory}
  (cartella) principale che si trova alla radice dell'albero, che si dirama in più directory fino ad arrivare alle foglie, 
  ovvero i file (che non possono ospitare altri file), è una struttura ricorsiva. Ci sono due tipi di file in Unix : \begin{itemize}
    \item \textbf{file non regolari} - Quei file che danno un \textit{accesso astratto} a periferiche e dispositivi, come già
    accennato, in Unix tutto può essere visto come un file o come un processo, de facto anche lo stesso mouse viene modellato come 
    un file, e sarà appunto un file di questo tipo.
    \item \textbf{file regolari} - Tutti i restanti file ordinari, come un file di testo o l'eseguibile di un programma.
  \end{itemize}
La directory root è indicata dal simbolo \shelll{/}, tutto è contenuto in tale cartella, anche una chiavetta USB che viene 
inserita nella macchina, i drive riceveranno una cartella sotto la root. Il file system impone alcune restrizioni sui nomi dei file : \begin{itemize}
    \item Non è possibile creare due file con lo stesso nome nella stessa directory.
    \item Non è possibile creare due directory con lo stesso nome nella stessa directory.
    \item Non è possibile creare una directory ed un file con lo stesso nome nella stessa directory.
\end{itemize}
\subsection{Operazioni sulle Directory}
Ogni singolo file del file system è raggiungibile mediante un cammino detto \textit{path}, una sequenza di nomi di directory 
separate dal carattere \shelll{/} che indicano la locazione del file, tale path può essere assoluto o relativo. In ogni sistema 
Unix, la directory \textit{home} dell'utente può anche essere indicata con il carattere \shelll{\(\sim\)}, infatti, i seguenti 
due path sono equivalenti : \acc 
\shelll{\(\sim\)/Immagini(faces)}\\
\shelll{home/Immagini(faces)}\acc
Nella shell, viene sempre visualizzata la directory corrente nella quale ci si trova, che di default è home appena si apre il 
terminale, cambiando la directory cambierà anche la dicitura che indica la current directory sul prompt.
\subsubsection{Comandi di Base}
Il comando \shelll{cd}, che sta per \textit{change directory}, serve a cambiare la directory corrente, e richiede come 
argomento un path, che può essere assoluto o relativo, se relativo, si riferirà alle directory contenute nella current directory, altrimenti 
si può dare il cosiddetto path assoluto, specificando la posizione a partire dalla root.\acc 
\shell{cd Immagini}\spaz per spostarsi nella cartella immagini\\
\shelll{casufrost@debian:$\sim$/Immagini\$}\acc 
Se non si passa alcun argomento, il comando sposta l'utente nella home. È possibile riferirsi alla directory padre 
con \shelll{cd ..} o alla directory corrente con \shelll{cd .}.\acc 
È possibile creare nuove cartelle con il comando \shelll{mkdir}, che sta per \textit{make directory}, prende come argomento 
il path di una cartella, se essa non esiste, verrà creata, è possibile utilizzare l'opzione \code{-p} per creare 
tutto un intero path specificato, creando l'intero cammino in un solo comando.\acc Un path assoluto è valido in qualunque caso, un 
path relativo è ovviamente dipendente dalla current directory, potrebbe quindi risultare non valido. Supponiamo che nel file 
system esista il seguente path : \code{home/animal/dog}, si avrà che : \acc 
\shell{cd dog} Non è valido, funzionerebbe se fossimo in \code{animal}\\
\shell{cd /home/casufrost/animal/dog} assoluto, quindi valido\acc 
Un altro comando estremamente utile è \shelll{ls}, che sta per \textit{list segments}, prende come argomento una directory (se 
omesso considera quella corrente), e mostra tutti i contenuti all'interno di essa, l'opzione \code{-l} mostra ulteriori informazioni 
utili, come i permessi di lettura o scrittura (verrà approfondito in seguito). \acc 
In Unix i file che iniziano con il punto, ad esempio \code{.secret.txt} sono nascosti, è possibile visualizzarli con il 
comando \shelll{ls -a}.\acc 
Esistono altri comandi secondari piuttosto utili : \shelll{tree} mostra l'alberazione della directory, \shelll{touch} crea 
un file vuoto, \shelll{pwd} stampa a schermo la directory corrente.
\subsection{Struttura del File System}
\subsubsection{Mounting e Partizioni}
Il file system può contenere dischi di memoria secondaria, anche dischi in reta, o addirittura una porzione della RAM, tutto 
grazie al meccanismo di \textbf{mounting}, ossia l'operazione di attaccare la radice del file system di un unità secondaria, ad una 
cartella appartenente al file system principale, ossia quello della radice root. \begin{center}
    \includegraphics[width=0.8\textwidth ]{images/mounting.eps}
\end{center}
Una qualsiasi directory dell'albero principale può diventare un \textit{punto di mount} di una qualsiasi altro 
file system, l'unico fatto da considerare è il seguente : Se viene montato un disco su una directory contenete dei file, 
tali file non saranno accessibili finché il mounting verrà rimosso, è quindi opportuno montare i dischi su directory vuote.\acc 
Un disco, può essere anche \textbf{partizionato}, ossia diviso in unità logiche disgiunte che il sistema operativo vedrà come 
 dischi differenti, è solito partizionare il disco in modo da avere un unità per il sistema operativo (che viene montata sulla 
 root) ed un unità per i dati dell'utente (che viene montata sulla home).
 Partizionare il disco risulta comodo ed aumenta il grado di sicurezza nell'organizzazione dei file, se dovesse accadere qualcosa 
 all'unità dell'OS, i dati utente non rimarrebbero corrotti. \acc 
 Linux funziona con diversi tipi di file system, un file system piuttosto utilizzato è quello di tipo \textit{Journal}, esso 
 tiene traccia di tutte le operazioni da eseguire sul disco, in caso di problemi ad esso, consultando il "diario", è possibile 
 avere informazioni riguardo le operazioni eseguite, e le operazioni da eseguire ma non completate, riducendo il danno.\acc 
 Diversi file system differiscono in caratteristiche quali : \begin{itemize}
    \item Dimensione massima delle unità di una partizione 
    \item Dimensione massima di un file
    \item Lunghezza massima per il nome di file o directory
 \end{itemize}
 In unix esistono due importanti file che tengono traccia dei dischi montati, il file \code{/etc/mtab} contiene informazioni 
 sui dischi montati all'avvio della macchina, \code{/etc/fstab} contiene informazioni sui dischi montati dinamicamente dall'utente, è 
 possibile visualizzare il contenuto di questi file (come di un qualsiasi altro file) tramite il comando \shelll{cat}.
 \subsubsection{Inode e Metadati}
 Come vengono gestiti i file all'interno del file system, o meglio, quale struttura dati è impiegata? Esiste una struttura chiama 
 \textbf{inode}, contenente ogni singolo file, identificato da un codice univoco detto \textit{inode number}, fisicamente quindi 
 non vi è un implementazione ad albero/gerarchica.\acc 
 Quando un file viene eliminato, non viene realmente cancellato fisicamente, viene solamente etichettato come "libero" l'inode 
 number ad esso associata, permettendo a nuovi eventuali file di venire associati a quel numero. Il numero totale di entrate 
 nell'inode è elevatissimo ma limitato, esiste quindi un limite al numero di file che possono coesistere nel sistema.\acc 
 Ogni file ha quindi un entrata nell'inode, che ne specifica il codice, ed altri \textit{metadati} utili riguardanti il file, 
 essi sono : \begin{itemize}
    \item Type - il suo tipo, se regolare o non regolare 
    \item User Id - l'Id dell'utente proprietario del file 
    \item Group Id - l'Id del gruppo primario del proprietario 
    \item Mode - permessi di lettura, scrittura ed accesso, riguardanti il proprietario, il gruppo del proprietario e 
    tutti gli altri  utenti
    \item Size - le dimensioni in byte del file 
    \item Timestamps - 3 marcature temporali riguardanti l'istante di cambiamento di un metadato, modifica e lettura del file.
    \item Data pointers - puntatore alla lista di blocchi che compone il file.
 \end{itemize} 
 Le directory contengono informazioni sugli inode number dei file che contengono, permettendo al sistema di seguire i percorsi 
 specificati dall'utente. Tramite il comando \shelll{ls -i},  è possibile visualizzare 
 l'inode number  nel terminale.\subsection{Permessi di Accesso}
 Nei metadati di un file, sono contenute delle informazioni riguardanti l'accesso, appunto del file, da parte dei vari utenti 
 che co-abitano l'ambiente di sistema. \begin{quote}
Supponiamo che il sig. Rossi per non perdere traccia dei suoi accessi ai vari servizi 
 online, si scriva tutte le sue password su un file di testo, che salva sul desktop. Il sig. Verdi, accede al medesimo sistema 
 (ovviamente con un utente differente), esso può visualizzare le password del sig. Rossi?    
\end{quote}
Ogni file contiene dei bit che definiscono i permessi di accesso per i vari utenti, esistono 3 diversi tipi di accesso : \begin{itemize}
    \item \code{r} - \textit{read}, accesso in lettura 
    \item \code{w} - \textit{write}, accesso in scrittura 
    \item \code{x} - \textit{execute}, accesso in esecuzione
\end{itemize}
Quest'ultimo è valido per le directory, una directory con l'accesso \code{x} può essere navigata. Per un file eseguibile non ha 
senso l'accesso \code{x} singolarmente, in quanto è necessario anche che il file venga letto.
Quindi ogni file ha 3 bit, che ne identificano gli accessi, essendo 3 bit, possono anche essere visti come un
numero intero da 0 a 7.\begin{center}
    \begin{tabular}{l|c|c|l|c|}
        \cline{2-5}
        \rowcolor[HTML]{C0C0C0} 
        \cellcolor[HTML]{FFFFFF}{\color[HTML]{FFFFFF} } & 4                                                 & 2                                                 & 1                         & permessi                \\ \hline
        \rowcolor[HTML]{EFEFEF} 
        \multicolumn{1}{|l|}{\cellcolor[HTML]{EFEFEF}0} & -                                                 & -                                                 & -                         & nessun permesso         \\ \hline
        \rowcolor[HTML]{EFEFEF} 
        \multicolumn{1}{|l|}{\cellcolor[HTML]{EFEFEF}1} & -                                                 & -                                                 & \code{x}& solo esecuzione         \\ \hline
        \rowcolor[HTML]{EFEFEF} 
        \multicolumn{1}{|l|}{\cellcolor[HTML]{EFEFEF}2} & -                                                 & \code{w}                        & -                         & solo scrittura          \\ \hline
        \rowcolor[HTML]{EFEFEF} 
        \multicolumn{1}{|l|}{\cellcolor[HTML]{EFEFEF}3} & -                                                 & \cellcolor[HTML]{EFEFEF}\code{w}& \code{x}& scrittura ed esecuzione \\ \hline
        \rowcolor[HTML]{EFEFEF} 
        \multicolumn{1}{|l|}{\cellcolor[HTML]{EFEFEF}4} & \cellcolor[HTML]{EFEFEF}\code{r} & -                                                 & -                         & solo lettura            \\ \hline
        \rowcolor[HTML]{EFEFEF} 
        \multicolumn{1}{|l|}{\cellcolor[HTML]{EFEFEF}5} & \cellcolor[HTML]{EFEFEF}\code{r} & -                                                 & \code{x}& lettura ed esecuzione   \\ \hline
        \rowcolor[HTML]{EFEFEF} 
        \multicolumn{1}{|l|}{\cellcolor[HTML]{EFEFEF}6} & \cellcolor[HTML]{EFEFEF}\code{r} & \cellcolor[HTML]{EFEFEF}\code{w}& -                         & lettura e scrittura     \\ \hline
        \rowcolor[HTML]{EFEFEF} 
        \multicolumn{1}{|l|}{\cellcolor[HTML]{EFEFEF}7} & \cellcolor[HTML]{EFEFEF}\code{r} & \cellcolor[HTML]{EFEFEF}\code{w}& \code{x}& tutti i permessi        \\ \hline
        \end{tabular}
\end{center}
Il fatto è che non esiste una sola tripla di bit, ma ne esistono ben 3, la prima identifica i permessi per l'utente proprietario 
del file in questione, la seconda identifica i permessi per gli utenti che appartengono al gruppo primario del proprietario del file, 
la terza identifica i permessi per tutti gli altri utenti. Ad esempio, se il file \code{frost.txt} ha i permessi 
\code{rwx,rwx,r--} o \code{774} può essere letto, scritto ed eseguito dal proprietario e dai membri del suo gruppo primario, 
mentra può essere esclusivamente letto da tutti gli altri utenti.
\acc
Esistono inoltre 3 ulteriori bit nei metadati di ogni file che consentono ulteriori permessi : \begin{itemize}
    \item \textbf{sticky bit} - Serve a proteggere le directory ed il loro contenuto dagli utenti non proprietari, un file in una 
    directory può essere acceduto da chi ha i permessi della directory ma non del file, con lo sticky bit, sarà necessario 
    essere proprietario del file in questione.
    \item \textbf{setuid bit} - Utilizzato esclusivamente per i file eseguibili, permette a coloro che eseguono il 
    file in questione di ottenere momentaneamente gli stessi permessi del proprietario del file, ad esempio il comando 
    \shelll{passwd} sfrutta tale bit, e permette ad un utente di modificare la propria password anche se il proprietario 
    del file è l'utente root.
    \item \textbf{setgid bit} - Analogo al precedente, ma riguardante il gruppo.
\end{itemize}
È possibile modificare i permessi di accesso ad un file tramite il comando \shelll{chmod}, specificando prima la tripla di ottali 
che identificherà i nuovi permessi, e poi il file in questione, è possibile anche cambiare il proprietario ed il gruppo di un 
file tramite \shelll{chown} e \shelll{chgrp}, se abbinati con l'opzine \shelll{-r}, tutti i sottoalberi dell'argomento 
riceveranno lo stesso trattamento.\acc Un importante valore di un sistema operativo Unix è la  \textit{user mask}, ossia 
una parola di bit che identifica i permessi di default che vengono assegnati ad un file nel momento della sua creazione.
La user mask è composta da quattro terne di 3 bit (rappresentanti i permessi ed i permessi speciali), e può essere modificata 
con il comando \shelll{umask} inserendo come parametro la nuova maschera.\acc 
I permessi di default di ogni file sono calcolati nel seguente modo : \begin{center}
    \code{111 111 111 111 AND NOT(\{user mask\})}
\end{center}
Ad esempio (escludendo i bit speciali) per impostare i diritti di default a 664, bisognerà performare il seguente comando : \begin{center}
    \shelll{umask 113}  \code{111 111 111 AND NOT(001 001 011) = 111 111 111 AND 110 110 100 = 110 110 100 = 664}
\end{center}
Altri comandi fondamentali per manipolare i file sono\begin{itemize} \item \shelll{cp} : Permette di copiare un file in una destinazione specificata
    \item \shelll{mv} : Permette di spostare un file in una destinazione specificata \item\shelll{rm} : Elimina il file specificato\acc 
\end{itemize}
Abbiamo poi visto che è possibile creare dei \textit{link o collegamenti} fra file, un \textit{soft link}, sarà un file che conterrà 
il puntatore ad un altro file, un \textit{hard link}, sarà invece un altro file, ma con il riferimento allo stesso inode number,
saranno quindi due file distinti, senza che però il disco sia occupato due volte.\acc 
È possibile creare dei link con il comando \shelll{ln}, l'eliminazione del file originale nega l'accesso a tutti 
i soft link ad esso collegati, per eliminare un file di cui invece esistono più hard link, bisogna eliminarli tutti.\acc 
Passiamo ora ad un comando particolare, ossia \shelll{dd}, tale comando è presente anche in delle primordiali versioni di Unix, e 
serve a copiare i file in maniera più sofisticata, opzionalmente effettuando conversioni, i suoi parametri assumono la 
sintassi \shelll{variabile=valore}, differentemente dal simbolo \shelll{-} utilizzato per gli altri comandi.\acc 
Può leggere e copiare i file \textit{byte per byte}, specificando il numero preciso di blocchi da copiare, la dimensione 
di tali blocchi, e 
dove scriverli all'interno del file di destinazione, a tal scopo ci sono le opzioni \code{count,bs,skip,of,if,seek}, ad esempio : \begin{itemize}
    \item \shelll{skip=x} - Del file da copiare, verranno ignorati i primi $x$ blocchi.
    \item \shelll{seek=x} - Nel file di destinazione, il contenuto verrà copiato a partire dal $x$-esimo blocco. 
\end{itemize}
\section{I Processi in Unix}
Abbiamo già accennato al fatto che in Unix ogni entità può essere vista come un file, le due componenti fondamentali di un 
sistema di questo tipo però, non sono esclusivamente i file, ma anche i \textit{processi}. Un processo 
rappresenta l'istanza di un programma/file eseguibile che viene avviato e caricato sulla memoria
principale, una volta avviato, l'OS si occuperà di tale processo, come i file, ogni processo è identificato da un numero 
intero univoco.\acc 
Per avviare un programma, e renderlo un processo, bisogna digitare sulla shell il codice del programma da eseguire, quando 
vengono richiamati i comandi \shelll{dd,ls,cat} e \shelll{cp}, vengono eseguiti dei nuovi processi, differentemente, i 
programmi \shelll{echo} e \shelll{cd}, che sono comandi interni, fanno parte del processo shell.\acc 
Uno stesso programma può essere istanziato più volte, dando vita a più processi copia di uno stesso programma che girano sulla 
macchina.
\subsection{Canali di Input/Output}
Ogni processo di Unix ha accesso a 3 canali/file di default, utili per il flusso di dati in input ed output, questi sono : \begin{itemize}
    \item \code{stdin} (\textit{standard input}) : Per il flusso di dati in input, ha il codice descrittore uguale a 0, e di default è impostata 
    la tastiera.
    \item \code{stdout} (\textit{standard output}) : Per il flusso di dati in output, ha il codice descrittore uguale a 1, e di default
    è impostato lo schermo.
    \item \code{stderr} (\textit{standard error}) : Secondo canale di output utile per eventuali errori e diagnostica, 
    ha il codice descrittore uguale a 1, e di default è impostato lo schermo.
\end{itemize}
I 3 canali possono essere "ridirezionati" dall'utente in maniera indipendente, ad esempio, è possibile cambiare il flusso di dati 
in output, facendo si che \code{stdout} venga impostato su un file, tutti i dati in output di un programma potranno quindi 
essere scritti su un file specificato, vale lo stesso principio per la lettura con \code{stdin}.\acc A tale scopo, quando 
si avviano i programmi dalla shell, bisogna utilizzare i simboli \code{<} e \code{>} per ridirezionare rispettivamente 
l'input e l'output, ad esempio : \acc 
\shell{ls > dirlist} : scriverà il risultato del comando sul file \code{dirlist}.\acc 
Il precedente citato \textit{descrittore di un file} è un identificatore univoco per ogni file, similmente all'inode, ma di 
più alto livello.
\subsection{Struttura di un Processo}
Ogni processo è identificato dal sistema con un codice 
univoco, un numero intero detto \textit{PID}. Oltre ciò, 
ogni processo ha un \textit{Process Control Block} (PCB), e 
6 aree di memoria dedicata.\acc 
Il PID 0 è assegnato ad un processo chiamato 
\code{init}, è il primo processo avviato dalla macchina e 
si occupa di avviare tutti gli altri processi. Quando un 
processo termina, il suo PID viene liberato, alcuni sistemi per 
ragioni di sicurezza assegnano i PID in maniera casuale.
Il PCB è una struttura dati contenente dei valori che forniscono 
informazioni su ogni processo, contiene: \begin{itemize}
    \item PID - Il suo codice identificativo 
    \item PPID - Il PID del suo processo padre
    \item Real UID - Id dell'utente proprietario 
    \item Real GID - Id del gruppo dell'utente proprietario 
    \item Effective UID - Id effettivo dell'utente assunto
    \item Effective GID - Id effettivo del gruppo dell'utente assunto
    \item Saved UID - 
\end{itemize}
\end{document}
